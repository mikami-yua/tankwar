0.1
产生一个800*600的窗口
让一个窗口显示出来：
     1.定义一个单独的Frame对象
     2.写一个类从frame继承
         第二种灵活，可以添加自己的成员变量和方法
0.2
 可以关闭窗口
 不允许窗口大小改动
 在这个frame上添加关于窗口关闭的事件，添加监听类
     1.写一个和这个class并排的类
     2.写一个内部类
     3.写一个匿名类
         匿名类的使用场合：类短小，不影响将来的扩展，不涉及重要业务逻辑

0.3
    画出可以代表坦克的实心圆

    画图：
        重写paint方法
        画实心圆需要四个参数：fillOval（x，y，w，h）
            xy是实心圆的外切正方形左上角点的位置
            w是方框的宽度，h是方块的高度

0.4
    坦克可以动：
        将位置改为变量
        启动线程不断重复
            写一个线程，每隔一段时间调用一次paint方法

            窗口启动之后就可以启动这个线程了

0.41
    使用双缓（doublebuffer）冲消除闪烁现象。
        会出现闪烁，原因：重画频率太快，paint方法还没有完成。
        解决：把所有的东西画在虚拟图片（画在内存上）上，一次性显示出来

        repain方法首先调用update（），update（）再调用paint。实际上每次重画的时候调用了update。需要在中间截掉。需要重写update方法

0.5
    代码重构：Frame的高度和宽度写为常量

0.6
    实现使用键盘对tank控制
        针对整个frame加一个对键盘的监听，处理对键盘的事件
        两种实现方式
            1.实现keylistener接口
                实现接口，里面的三个方法无论是否关心都需要实现
            2.从keyAdpater继承
                以及写了空的实现，只要写关心的方法就行了

0.7
    将坦克单独包装成类
        建立tank类
        为tank类添加成员变量xy
        添加draw方法，使tank类独立控制自己的画法
        添加tank类处理按键的方法

0.8
    tank可以在8个方向行走（处理同时按下两个键）
    原来：每按下一个键改变一次行动的方向。不便：键盘事件不均匀，移动就不均匀
    改进：每次按下后再键盘事件里只改变方向，在draw方法里根据方向改变位置。

    添加记录按键类型的布尔量
    添加代表方向的布尔量
    根据按键状态确定方向
    根据方向确定下一次的move

0.9
    按键按一下变成true，就永远使true了。
    改进：当键盘抬起来时设置为false

1.0 按下ctrl后，向那个方向打一发炮弹（p11）
    添加missile类有xy，dir属性
    在TankClient中模拟一颗子弹
        new一颗子弹

1.1 增加对crtl键的处理
    使子弹从tank的中间打出来

1.2 tank停止时子弹不动
    定义炮筒的方向
    用一根直线模拟炮筒

1.3 炮弹可以有好多个
    使用容器装炮弹
    抬起CTRL时容器中装入新的炮弹
    逐一画出每一发炮弹.
    按着发射太密集，设置为抬起时发生

1.4解决炮弹不消亡的问题，解决坦克出界的问题
    炮弹飞出边界就消亡,专门有一个线程清理炮弹
    tc相当于一个大管家，下面的类都归它管，想要干事方便，最好有一个tc的引用（调停者设计模式）

1.5 画一个敌人坦克
    加入区分敌我的量good
    使用ctrl + alt + H 查看调用这个方法的方法

1.6 使敌人的tank可以被击中，一颗子弹击中敌人坦克
    子弹是否击中敌人
    碰撞检测：
        坦克外围的方块和子弹外围的方块相交就算碰上
    碰撞检测辅助类：
        Rectangle
        为Tank和Missile都加入getRect方法
        当碰撞时，子弹消失，坦克也消失
        坦克就算已经死了，但还是在那个位置上

1.7 增加爆炸效果
    用直径不同的圆来模拟爆炸
    爆炸应该有好多个

1.8 多辆坦克

1.9 敌人的坦克至少能动
    添加简单的AI

1.9.1 敌人的坦克先动起来
    有方向就能向前走
    每移动一步，就给一个随机的方向
    private static Random r=new Random();//建立一个随机数产生器,不会制造一个tank就有一个随机数产生器。有一个就够了
        定义为静态的，多个对象共享他一个

    enum Direction{//枚举8个方向和停止
            L,LU,U,RU,R,RD,D,LD,STOP
        };
    是个枚举类型
    有方法使其直接转换为数组
        Direction[] dirs=Direction.values();//转换为数组
        int rn=r.nextInt(dirs.length);//产生一个随机的整数，在8以内

1.9.2 使敌人运动的更正常
    朝某个方向移动固定的步数之后再转向。1.9.1是50ms换一个方向

1.9.3 敌人的tank可以达炮弹

2.0 加墙
    墙不能过，子弹打上去会消失
     this.dir=Direction.STOP;这么写会导致bot粘到墙上
     解决办法，记录撞墙前上一次的位置，撞到会，回溯状态
     子弹速度太快会穿过墙（每次移动50，墙的宽度只有10）

2.1
    tank不能互相穿越
        撞到时使用stayback回溯

2.2 p33
    超级炮弹-A（可以向8个方向发射）

2.3
    tank 生命值

2.4
    图形化表示生命值

2.5
    添加可以回血的血块
    沿固定的轨迹运动，过一段时间后消失

2.5
    敌人死完了重新加入
    玩家死了f2开始

end
    生成javadocs文档
    生成jar文件




*******************************************************************************************************
version 3

3.1 修正上个版本
    子弹颜色区分
    对于classloader，每个.class都是一个对象


3.2 加入坦克的图片

3.3 子弹加图片

3.4 配置文件增加灵活性
    单例设计模式

3.5 网络版开始
    先剔除无关的内容
        去掉敌人的tank

3.5.1 Server需要两个
        tcp用于建立客户端连接
        udp用于转发游戏数据
        server建立好之后需要client端连接到server

3.5.2 问题：要不要存储client端的TCP socket
    UDP：在Server端有一个线程，一个单独的udp接受线程。如有一个客户端给Server发了一个信息。Server这个udp线程接受到之后
        会转发给其他的客户端。所以对于Server来说，需要保存客户端的相关信息（发到那个ip，那个端口应该知道）。知道这些端口
        需要在tcp连上来以后就保存。保存到list中后
    保留也行不保留也行：
        保留：当断开连接的时候tcp4次挥手
        不保留：使用udp模拟断开的重传机制
    这里不保留了，所以tankclient打socket在传完数据后就可以关闭了

3.5.3 UPD端口号没有去重需要解决
      为每个客户端建立一个id，产生一个独一无二的号码
        java.util.uuid

3.5.4 多个客户联网，并发送坦克诞生的消息
        知识点1：new一个udp的socket
                DatagramSocket ds=new DatagramSocket(UDP_PORT);
        知识点2：DatagramPacket
             在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用“集装箱”进行打包，
             为此JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。

             在创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同，接收端的构造方法只需要接收一个字节数组来
             存放接收到的数据，而发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定发送端IP地址和端口号。接下来
             根据API文档的内容，对DatagramPacket的构造方法进行逐一详细地讲解。
             DatagramPacket dp=new DatagramPacket(buf,buf.length);

             DatagramPacket数据包的作用就如同是“集装箱”，可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”
             是不够的，还需要有码头。在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。
             DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包
        知识点3：通过服务的receive方法将接收到的数据存入到数据包中

        客户端应该在连上服务器时发送udp数据包，告诉大家，有新人加入，应该更新数据

        怎么把一个信息发送出去：
                    1.首先转换为字节数组,new出来ByteArrayOutputStream之后内存里就有了字节数组，默认32字节。可以自动增长
                    2.把tank相关信息写入
                    3.把字节数组封装为datagrampacket
                        bytesArr.toByteArray()把写好数据的字节数组转换

3.5.5 服务器接受到tank的创建消息后，把这个消息分发给其他的客户端

3.5.6 把从服务器接受到底udp数据解析后画在自己本地
        如果不是自己的id号，再检查Tankclient中是否装着这个tank。如果没有，说明是新的tank

3.5.7 看到tank的移动，只要移动就发送消息

3.5.8 后加入的tank也能看到之前的tank
        出现tank的位置不同步的问题
        【解决方案】每隔一段时间，对位置和方向进行一次同步或者加入xy的位置信息
            使用xy同步位置信息可能仍然不准确，因为udp可能会丢包

3.5.9 客户端自己指定UDP端口号
    Dialog类
        Model Dialog必须处理完弹出的窗口后，才能继续操作
        Modeless Dialog弹出的窗口不影响其他的操作